// @generated by protobuf-ts 2.0.6
// @generated from protobuf file "rustplus.proto" (package "rustplus", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// This took me a while to craft by hand ðŸ˜´

/**
 * @generated from protobuf message rustplus.AppMessage
 */
export interface AppMessage {
    /**
     * @generated from protobuf field: optional rustplus.AppResponse response = 1;
     */
    response?: AppResponse;
    /**
     * @generated from protobuf field: optional rustplus.AppBroadcast broadcast = 2;
     */
    broadcast?: AppBroadcast;
}
/**
 * @generated from protobuf message rustplus.AppRequest
 */
export interface AppRequest {
    /**
     * @generated from protobuf field: uint32 seq = 1;
     */
    seq: number;
    /**
     * @generated from protobuf field: uint64 playerId = 2 [jstype = JS_STRING];
     */
    playerId: string;
    /**
     * @generated from protobuf field: int32 playerToken = 3;
     */
    playerToken: number;
    /**
     * @generated from protobuf field: optional uint32 entityId = 4;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getInfo = 8;
     */
    getInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getTime = 9;
     */
    getTime?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getMap = 10;
     */
    getMap?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getTeamInfo = 11;
     */
    getTeamInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getTeamChat = 12;
     */
    getTeamChat?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppSendMessage sendTeamMessage = 13;
     */
    sendTeamMessage?: AppSendMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getEntityInfo = 14;
     */
    getEntityInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppSetEntityValue setEntityValue = 15;
     */
    setEntityValue?: AppSetEntityValue;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty checkSubscription = 16;
     */
    checkSubscription?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppFlag setSubscription = 17;
     */
    setSubscription?: AppFlag;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getMapMarkers = 18;
     */
    getMapMarkers?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppCameraFrameRequest getCameraFrame = 19;
     */
    getCameraFrame?: AppCameraFrameRequest;
    /**
     * @generated from protobuf field: optional rustplus.AppPromoteToLeader promoteToLeader = 20;
     */
    promoteToLeader?: AppPromoteToLeader;
}
/**
 * @generated from protobuf message rustplus.AppSendMessage
 */
export interface AppSendMessage {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message rustplus.AppSetEntityValue
 */
export interface AppSetEntityValue {
    /**
     * @generated from protobuf field: bool value = 1;
     */
    value: boolean;
}
/**
 * @generated from protobuf message rustplus.AppCameraFrameRequest
 */
export interface AppCameraFrameRequest {
    /**
     * @generated from protobuf field: string identifier = 1;
     */
    identifier: string;
    /**
     * @generated from protobuf field: uint32 frame = 2;
     */
    frame: number;
}
/**
 * @generated from protobuf message rustplus.AppPromoteToLeader
 */
export interface AppPromoteToLeader {
    /**
     * @generated from protobuf field: uint64 steamId = 1 [jstype = JS_STRING];
     */
    steamId: string;
}
/**
 * @generated from protobuf message rustplus.AppResponse
 */
export interface AppResponse {
    /**
     * @generated from protobuf field: uint32 seq = 1;
     */
    seq: number;
    /**
     * @generated from protobuf field: optional rustplus.AppSuccess success = 4;
     */
    success?: AppSuccess;
    /**
     * @generated from protobuf field: optional rustplus.AppError error = 5;
     */
    error?: AppError;
    /**
     * @generated from protobuf field: optional rustplus.AppInfo info = 6;
     */
    info?: AppInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppTime time = 7;
     */
    time?: AppTime;
    /**
     * @generated from protobuf field: optional rustplus.AppMap map = 8;
     */
    map?: AppMap;
    /**
     * @generated from protobuf field: optional rustplus.AppTeamInfo teamInfo = 9;
     */
    teamInfo?: AppTeamInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppTeamChat teamChat = 10;
     */
    teamChat?: AppTeamChat;
    /**
     * @generated from protobuf field: optional rustplus.AppEntityInfo entityInfo = 11;
     */
    entityInfo?: AppEntityInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppFlag flag = 12;
     */
    flag?: AppFlag;
    /**
     * @generated from protobuf field: optional rustplus.AppMapMarkers mapMarkers = 13;
     */
    mapMarkers?: AppMapMarkers;
    /**
     * @generated from protobuf field: optional rustplus.AppCameraFrame cameraFrame = 14;
     */
    cameraFrame?: AppCameraFrame;
}
/**
 * @generated from protobuf message rustplus.AppBroadcast
 */
export interface AppBroadcast {
    /**
     * @generated from protobuf field: optional rustplus.AppTeamChanged teamChanged = 4;
     */
    teamChanged?: AppTeamChanged;
    /**
     * @generated from protobuf field: optional rustplus.AppTeamMessage teamMessage = 5;
     */
    teamMessage?: AppTeamMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppEntityChanged entityChanged = 6;
     */
    entityChanged?: AppEntityChanged;
}
/**
 * @generated from protobuf message rustplus.AppEmpty
 */
export interface AppEmpty {
}
/**
 * @generated from protobuf message rustplus.AppSuccess
 */
export interface AppSuccess {
}
/**
 * @generated from protobuf message rustplus.AppError
 */
export interface AppError {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string;
}
/**
 * @generated from protobuf message rustplus.AppInfo
 */
export interface AppInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string headerImage = 2;
     */
    headerImage: string;
    /**
     * @generated from protobuf field: string url = 3;
     */
    url: string;
    /**
     * @generated from protobuf field: string map = 4;
     */
    map: string;
    /**
     * @generated from protobuf field: uint32 mapSize = 5;
     */
    mapSize: number;
    /**
     * @generated from protobuf field: uint32 wipeTime = 6;
     */
    wipeTime: number;
    /**
     * @generated from protobuf field: uint32 players = 7;
     */
    players: number;
    /**
     * @generated from protobuf field: uint32 maxPlayers = 8;
     */
    maxPlayers: number;
    /**
     * @generated from protobuf field: uint32 queuedPlayers = 9;
     */
    queuedPlayers: number;
    /**
     * @generated from protobuf field: optional uint32 seed = 10;
     */
    seed?: number;
    /**
     * @generated from protobuf field: optional uint32 salt = 11;
     */
    salt?: number;
}
/**
 * @generated from protobuf message rustplus.AppTime
 */
export interface AppTime {
    /**
     * @generated from protobuf field: float dayLengthMinutes = 1;
     */
    dayLengthMinutes: number;
    /**
     * @generated from protobuf field: float timeScale = 2;
     */
    timeScale: number;
    /**
     * @generated from protobuf field: float sunrise = 3;
     */
    sunrise: number;
    /**
     * @generated from protobuf field: float sunset = 4;
     */
    sunset: number;
    /**
     * @generated from protobuf field: float time = 5;
     */
    time: number;
}
/**
 * @generated from protobuf message rustplus.AppMap
 */
export interface AppMap {
    /**
     * @generated from protobuf field: uint32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
    /**
     * @generated from protobuf field: bytes jpgImage = 3;
     */
    jpgImage: Uint8Array;
    /**
     * @generated from protobuf field: int32 oceanMargin = 4;
     */
    oceanMargin: number;
    /**
     * @generated from protobuf field: repeated rustplus.AppMap.Monument monuments = 5;
     */
    monuments: AppMap_Monument[];
    /**
     * @generated from protobuf field: optional string background = 6;
     */
    background?: string;
}
/**
 * @generated from protobuf message rustplus.AppMap.Monument
 */
export interface AppMap_Monument {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamInfo
 */
export interface AppTeamInfo {
    /**
     * @generated from protobuf field: uint64 leaderSteamId = 1 [jstype = JS_STRING];
     */
    leaderSteamId: string;
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamInfo.Member members = 2;
     */
    members: AppTeamInfo_Member[];
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamInfo.Note mapNotes = 3;
     */
    mapNotes: AppTeamInfo_Note[];
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamInfo.Note leaderMapNotes = 4;
     */
    leaderMapNotes: AppTeamInfo_Note[];
}
/**
 * @generated from protobuf message rustplus.AppTeamInfo.Member
 */
export interface AppTeamInfo_Member {
    /**
     * @generated from protobuf field: uint64 steamId = 1 [jstype = JS_STRING];
     */
    steamId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: bool isOnline = 5;
     */
    isOnline: boolean;
    /**
     * @generated from protobuf field: uint32 spawnTime = 6;
     */
    spawnTime: number;
    /**
     * @generated from protobuf field: bool isAlive = 7;
     */
    isAlive: boolean;
    /**
     * @generated from protobuf field: uint32 deathTime = 8;
     */
    deathTime: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamInfo.Note
 */
export interface AppTeamInfo_Note {
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamChat
 */
export interface AppTeamChat {
    /**
     * @generated from protobuf field: repeated rustplus.AppChatMessage messages = 1;
     */
    messages: AppChatMessage[];
}
/**
 * @generated from protobuf message rustplus.AppChatMessage
 */
export interface AppChatMessage {
    /**
     * @generated from protobuf field: uint64 steamId = 1 [jstype = JS_STRING];
     */
    steamId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: string color = 4;
     */
    color: string;
    /**
     * @generated from protobuf field: uint32 time = 5;
     */
    time: number;
}
/**
 * @generated from protobuf message rustplus.AppEntityInfo
 */
export interface AppEntityInfo {
    /**
     * @generated from protobuf field: rustplus.AppEntityType type = 1;
     */
    type: AppEntityType;
    /**
     * @generated from protobuf field: rustplus.AppEntityPayload payload = 3;
     */
    payload?: AppEntityPayload;
}
/**
 * @generated from protobuf message rustplus.AppEntityPayload
 */
export interface AppEntityPayload {
    /**
     * @generated from protobuf field: optional bool value = 1;
     */
    value?: boolean;
    /**
     * @generated from protobuf field: repeated rustplus.AppEntityPayload.Item items = 2;
     */
    items: AppEntityPayload_Item[];
    /**
     * @generated from protobuf field: optional int32 capacity = 3;
     */
    capacity?: number;
    /**
     * @generated from protobuf field: optional bool hasProtection = 4;
     */
    hasProtection?: boolean;
    /**
     * @generated from protobuf field: optional uint32 protectionExpiry = 5;
     */
    protectionExpiry?: number;
}
/**
 * @generated from protobuf message rustplus.AppEntityPayload.Item
 */
export interface AppEntityPayload_Item {
    /**
     * @generated from protobuf field: int32 itemId = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: bool itemIsBlueprint = 3;
     */
    itemIsBlueprint: boolean;
}
/**
 * @generated from protobuf message rustplus.AppFlag
 */
export interface AppFlag {
    /**
     * @generated from protobuf field: bool value = 1;
     */
    value: boolean;
}
/**
 * @generated from protobuf message rustplus.AppMapMarkers
 */
export interface AppMapMarkers {
    /**
     * @generated from protobuf field: repeated rustplus.AppMarker markers = 1;
     */
    markers: AppMarker[];
}
/**
 * @generated from protobuf message rustplus.Vector4
 */
export interface Vector4 {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
    /**
     * @generated from protobuf field: optional float w = 4;
     */
    w?: number;
}
/**
 * @generated from protobuf message rustplus.AppMarker
 */
export interface AppMarker {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: rustplus.AppMarkerType type = 2;
     */
    type: AppMarkerType;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: optional uint64 steamId = 5 [jstype = JS_STRING];
     */
    steamId?: string;
    /**
     * @generated from protobuf field: optional float rotation = 6;
     */
    rotation?: number;
    /**
     * @generated from protobuf field: optional float radius = 7;
     */
    radius?: number;
    /**
     * @generated from protobuf field: optional rustplus.Vector4 color1 = 8;
     */
    color1?: Vector4;
    /**
     * @generated from protobuf field: optional rustplus.Vector4 color2 = 9;
     */
    color2?: Vector4;
    /**
     * @generated from protobuf field: optional float alpha = 10;
     */
    alpha?: number;
    /**
     * @generated from protobuf field: optional string name = 11;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated rustplus.AppMarker.SellOrder sellOrders = 13;
     */
    sellOrders: AppMarker_SellOrder[];
}
/**
 * @generated from protobuf message rustplus.AppMarker.SellOrder
 */
export interface AppMarker_SellOrder {
    /**
     * @generated from protobuf field: int32 itemId = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 currencyId = 3;
     */
    currencyId: number;
    /**
     * @generated from protobuf field: int32 costPerItem = 4;
     */
    costPerItem: number;
    /**
     * @generated from protobuf field: int32 amountInStock = 5;
     */
    amountInStock: number;
    /**
     * @generated from protobuf field: bool itemIsBlueprint = 6;
     */
    itemIsBlueprint: boolean;
    /**
     * @generated from protobuf field: bool currencyIsBlueprint = 7;
     */
    currencyIsBlueprint: boolean;
}
/**
 * @generated from protobuf message rustplus.AppCameraFrame
 */
export interface AppCameraFrame {
    /**
     * @generated from protobuf field: uint32 frame = 1;
     */
    frame: number;
    /**
     * @generated from protobuf field: bytes jpgImage = 2;
     */
    jpgImage: Uint8Array;
}
/**
 * @generated from protobuf message rustplus.AppTeamChanged
 */
export interface AppTeamChanged {
    /**
     * @generated from protobuf field: uint64 playerId = 1 [jstype = JS_STRING];
     */
    playerId: string;
    /**
     * @generated from protobuf field: rustplus.AppTeamInfo teamInfo = 2;
     */
    teamInfo?: AppTeamInfo;
}
/**
 * @generated from protobuf message rustplus.AppTeamMessage
 */
export interface AppTeamMessage {
    /**
     * @generated from protobuf field: rustplus.AppChatMessage message = 1;
     */
    message?: AppChatMessage;
}
/**
 * @generated from protobuf message rustplus.AppEntityChanged
 */
export interface AppEntityChanged {
    /**
     * @generated from protobuf field: uint32 entityId = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: rustplus.AppEntityPayload payload = 2;
     */
    payload?: AppEntityPayload;
}
/**
 * @generated from protobuf enum rustplus.AppEntityType
 */
export enum AppEntityType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: Switch = 1;
     */
    Switch = 1,
    /**
     * @generated from protobuf enum value: Alarm = 2;
     */
    Alarm = 2,
    /**
     * @generated from protobuf enum value: StorageMonitor = 3;
     */
    StorageMonitor = 3
}
/**
 * @generated from protobuf enum rustplus.AppMarkerType
 */
export enum AppMarkerType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: Player = 1;
     */
    Player = 1,
    /**
     * @generated from protobuf enum value: Explosion = 2;
     */
    Explosion = 2,
    /**
     * @generated from protobuf enum value: VendingMachine = 3;
     */
    VendingMachine = 3,
    /**
     * @generated from protobuf enum value: CH47 = 4;
     */
    CH47 = 4,
    /**
     * @generated from protobuf enum value: CargoShip = 5;
     */
    CargoShip = 5,
    /**
     * @generated from protobuf enum value: Crate = 6;
     */
    Crate = 6,
    /**
     * @generated from protobuf enum value: GenericRadius = 7;
     */
    GenericRadius = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class AppMessage$Type extends MessageType<AppMessage> {
    constructor() {
        super("rustplus.AppMessage", [
            { no: 1, name: "response", kind: "message", T: () => AppResponse },
            { no: 2, name: "broadcast", kind: "message", T: () => AppBroadcast }
        ]);
    }
    create(value?: PartialMessage<AppMessage>): AppMessage {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMessage): AppMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.AppResponse response */ 1:
                    message.response = AppResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                case /* optional rustplus.AppBroadcast broadcast */ 2:
                    message.broadcast = AppBroadcast.internalBinaryRead(reader, reader.uint32(), options, message.broadcast);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.AppResponse response = 1; */
        if (message.response)
            AppResponse.internalBinaryWrite(message.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppBroadcast broadcast = 2; */
        if (message.broadcast)
            AppBroadcast.internalBinaryWrite(message.broadcast, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMessage
 */
export const AppMessage = new AppMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppRequest$Type extends MessageType<AppRequest> {
    constructor() {
        super("rustplus.AppRequest", [
            { no: 1, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "playerToken", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "entityId", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "getInfo", kind: "message", T: () => AppEmpty },
            { no: 9, name: "getTime", kind: "message", T: () => AppEmpty },
            { no: 10, name: "getMap", kind: "message", T: () => AppEmpty },
            { no: 11, name: "getTeamInfo", kind: "message", T: () => AppEmpty },
            { no: 12, name: "getTeamChat", kind: "message", T: () => AppEmpty },
            { no: 13, name: "sendTeamMessage", kind: "message", T: () => AppSendMessage },
            { no: 14, name: "getEntityInfo", kind: "message", T: () => AppEmpty },
            { no: 15, name: "setEntityValue", kind: "message", T: () => AppSetEntityValue },
            { no: 16, name: "checkSubscription", kind: "message", T: () => AppEmpty },
            { no: 17, name: "setSubscription", kind: "message", T: () => AppFlag },
            { no: 18, name: "getMapMarkers", kind: "message", T: () => AppEmpty },
            { no: 19, name: "getCameraFrame", kind: "message", T: () => AppCameraFrameRequest },
            { no: 20, name: "promoteToLeader", kind: "message", T: () => AppPromoteToLeader }
        ]);
    }
    create(value?: PartialMessage<AppRequest>): AppRequest {
        const message = { seq: 0, playerId: "0", playerToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppRequest): AppRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 seq */ 1:
                    message.seq = reader.uint32();
                    break;
                case /* uint64 playerId = 2 [jstype = JS_STRING];*/ 2:
                    message.playerId = reader.uint64().toString();
                    break;
                case /* int32 playerToken */ 3:
                    message.playerToken = reader.int32();
                    break;
                case /* optional uint32 entityId */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* optional rustplus.AppEmpty getInfo */ 8:
                    message.getInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getInfo);
                    break;
                case /* optional rustplus.AppEmpty getTime */ 9:
                    message.getTime = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getTime);
                    break;
                case /* optional rustplus.AppEmpty getMap */ 10:
                    message.getMap = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getMap);
                    break;
                case /* optional rustplus.AppEmpty getTeamInfo */ 11:
                    message.getTeamInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getTeamInfo);
                    break;
                case /* optional rustplus.AppEmpty getTeamChat */ 12:
                    message.getTeamChat = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getTeamChat);
                    break;
                case /* optional rustplus.AppSendMessage sendTeamMessage */ 13:
                    message.sendTeamMessage = AppSendMessage.internalBinaryRead(reader, reader.uint32(), options, message.sendTeamMessage);
                    break;
                case /* optional rustplus.AppEmpty getEntityInfo */ 14:
                    message.getEntityInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getEntityInfo);
                    break;
                case /* optional rustplus.AppSetEntityValue setEntityValue */ 15:
                    message.setEntityValue = AppSetEntityValue.internalBinaryRead(reader, reader.uint32(), options, message.setEntityValue);
                    break;
                case /* optional rustplus.AppEmpty checkSubscription */ 16:
                    message.checkSubscription = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.checkSubscription);
                    break;
                case /* optional rustplus.AppFlag setSubscription */ 17:
                    message.setSubscription = AppFlag.internalBinaryRead(reader, reader.uint32(), options, message.setSubscription);
                    break;
                case /* optional rustplus.AppEmpty getMapMarkers */ 18:
                    message.getMapMarkers = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getMapMarkers);
                    break;
                case /* optional rustplus.AppCameraFrameRequest getCameraFrame */ 19:
                    message.getCameraFrame = AppCameraFrameRequest.internalBinaryRead(reader, reader.uint32(), options, message.getCameraFrame);
                    break;
                case /* optional rustplus.AppPromoteToLeader promoteToLeader */ 20:
                    message.promoteToLeader = AppPromoteToLeader.internalBinaryRead(reader, reader.uint32(), options, message.promoteToLeader);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 seq = 1; */
        if (message.seq !== 0)
            writer.tag(1, WireType.Varint).uint32(message.seq);
        /* uint64 playerId = 2 [jstype = JS_STRING]; */
        if (message.playerId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.playerId);
        /* int32 playerToken = 3; */
        if (message.playerToken !== 0)
            writer.tag(3, WireType.Varint).int32(message.playerToken);
        /* optional uint32 entityId = 4; */
        if (message.entityId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* optional rustplus.AppEmpty getInfo = 8; */
        if (message.getInfo)
            AppEmpty.internalBinaryWrite(message.getInfo, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getTime = 9; */
        if (message.getTime)
            AppEmpty.internalBinaryWrite(message.getTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getMap = 10; */
        if (message.getMap)
            AppEmpty.internalBinaryWrite(message.getMap, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getTeamInfo = 11; */
        if (message.getTeamInfo)
            AppEmpty.internalBinaryWrite(message.getTeamInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getTeamChat = 12; */
        if (message.getTeamChat)
            AppEmpty.internalBinaryWrite(message.getTeamChat, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppSendMessage sendTeamMessage = 13; */
        if (message.sendTeamMessage)
            AppSendMessage.internalBinaryWrite(message.sendTeamMessage, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getEntityInfo = 14; */
        if (message.getEntityInfo)
            AppEmpty.internalBinaryWrite(message.getEntityInfo, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppSetEntityValue setEntityValue = 15; */
        if (message.setEntityValue)
            AppSetEntityValue.internalBinaryWrite(message.setEntityValue, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty checkSubscription = 16; */
        if (message.checkSubscription)
            AppEmpty.internalBinaryWrite(message.checkSubscription, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppFlag setSubscription = 17; */
        if (message.setSubscription)
            AppFlag.internalBinaryWrite(message.setSubscription, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getMapMarkers = 18; */
        if (message.getMapMarkers)
            AppEmpty.internalBinaryWrite(message.getMapMarkers, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppCameraFrameRequest getCameraFrame = 19; */
        if (message.getCameraFrame)
            AppCameraFrameRequest.internalBinaryWrite(message.getCameraFrame, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppPromoteToLeader promoteToLeader = 20; */
        if (message.promoteToLeader)
            AppPromoteToLeader.internalBinaryWrite(message.promoteToLeader, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppRequest
 */
export const AppRequest = new AppRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSendMessage$Type extends MessageType<AppSendMessage> {
    constructor() {
        super("rustplus.AppSendMessage", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppSendMessage>): AppSendMessage {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppSendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSendMessage): AppSendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppSendMessage
 */
export const AppSendMessage = new AppSendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSetEntityValue$Type extends MessageType<AppSetEntityValue> {
    constructor() {
        super("rustplus.AppSetEntityValue", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppSetEntityValue>): AppSetEntityValue {
        const message = { value: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppSetEntityValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSetEntityValue): AppSetEntityValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSetEntityValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppSetEntityValue
 */
export const AppSetEntityValue = new AppSetEntityValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraFrameRequest$Type extends MessageType<AppCameraFrameRequest> {
    constructor() {
        super("rustplus.AppCameraFrameRequest", [
            { no: 1, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "frame", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppCameraFrameRequest>): AppCameraFrameRequest {
        const message = { identifier: "", frame: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppCameraFrameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraFrameRequest): AppCameraFrameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string identifier */ 1:
                    message.identifier = reader.string();
                    break;
                case /* uint32 frame */ 2:
                    message.frame = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraFrameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string identifier = 1; */
        if (message.identifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier);
        /* uint32 frame = 2; */
        if (message.frame !== 0)
            writer.tag(2, WireType.Varint).uint32(message.frame);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraFrameRequest
 */
export const AppCameraFrameRequest = new AppCameraFrameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppPromoteToLeader$Type extends MessageType<AppPromoteToLeader> {
    constructor() {
        super("rustplus.AppPromoteToLeader", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<AppPromoteToLeader>): AppPromoteToLeader {
        const message = { steamId: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppPromoteToLeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppPromoteToLeader): AppPromoteToLeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId = 1 [jstype = JS_STRING];*/ 1:
                    message.steamId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppPromoteToLeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1 [jstype = JS_STRING]; */
        if (message.steamId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppPromoteToLeader
 */
export const AppPromoteToLeader = new AppPromoteToLeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppResponse$Type extends MessageType<AppResponse> {
    constructor() {
        super("rustplus.AppResponse", [
            { no: 1, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "success", kind: "message", T: () => AppSuccess },
            { no: 5, name: "error", kind: "message", T: () => AppError },
            { no: 6, name: "info", kind: "message", T: () => AppInfo },
            { no: 7, name: "time", kind: "message", T: () => AppTime },
            { no: 8, name: "map", kind: "message", T: () => AppMap },
            { no: 9, name: "teamInfo", kind: "message", T: () => AppTeamInfo },
            { no: 10, name: "teamChat", kind: "message", T: () => AppTeamChat },
            { no: 11, name: "entityInfo", kind: "message", T: () => AppEntityInfo },
            { no: 12, name: "flag", kind: "message", T: () => AppFlag },
            { no: 13, name: "mapMarkers", kind: "message", T: () => AppMapMarkers },
            { no: 14, name: "cameraFrame", kind: "message", T: () => AppCameraFrame }
        ]);
    }
    create(value?: PartialMessage<AppResponse>): AppResponse {
        const message = { seq: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppResponse): AppResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 seq */ 1:
                    message.seq = reader.uint32();
                    break;
                case /* optional rustplus.AppSuccess success */ 4:
                    message.success = AppSuccess.internalBinaryRead(reader, reader.uint32(), options, message.success);
                    break;
                case /* optional rustplus.AppError error */ 5:
                    message.error = AppError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* optional rustplus.AppInfo info */ 6:
                    message.info = AppInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* optional rustplus.AppTime time */ 7:
                    message.time = AppTime.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* optional rustplus.AppMap map */ 8:
                    message.map = AppMap.internalBinaryRead(reader, reader.uint32(), options, message.map);
                    break;
                case /* optional rustplus.AppTeamInfo teamInfo */ 9:
                    message.teamInfo = AppTeamInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamInfo);
                    break;
                case /* optional rustplus.AppTeamChat teamChat */ 10:
                    message.teamChat = AppTeamChat.internalBinaryRead(reader, reader.uint32(), options, message.teamChat);
                    break;
                case /* optional rustplus.AppEntityInfo entityInfo */ 11:
                    message.entityInfo = AppEntityInfo.internalBinaryRead(reader, reader.uint32(), options, message.entityInfo);
                    break;
                case /* optional rustplus.AppFlag flag */ 12:
                    message.flag = AppFlag.internalBinaryRead(reader, reader.uint32(), options, message.flag);
                    break;
                case /* optional rustplus.AppMapMarkers mapMarkers */ 13:
                    message.mapMarkers = AppMapMarkers.internalBinaryRead(reader, reader.uint32(), options, message.mapMarkers);
                    break;
                case /* optional rustplus.AppCameraFrame cameraFrame */ 14:
                    message.cameraFrame = AppCameraFrame.internalBinaryRead(reader, reader.uint32(), options, message.cameraFrame);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 seq = 1; */
        if (message.seq !== 0)
            writer.tag(1, WireType.Varint).uint32(message.seq);
        /* optional rustplus.AppSuccess success = 4; */
        if (message.success)
            AppSuccess.internalBinaryWrite(message.success, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppError error = 5; */
        if (message.error)
            AppError.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppInfo info = 6; */
        if (message.info)
            AppInfo.internalBinaryWrite(message.info, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTime time = 7; */
        if (message.time)
            AppTime.internalBinaryWrite(message.time, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppMap map = 8; */
        if (message.map)
            AppMap.internalBinaryWrite(message.map, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTeamInfo teamInfo = 9; */
        if (message.teamInfo)
            AppTeamInfo.internalBinaryWrite(message.teamInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTeamChat teamChat = 10; */
        if (message.teamChat)
            AppTeamChat.internalBinaryWrite(message.teamChat, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEntityInfo entityInfo = 11; */
        if (message.entityInfo)
            AppEntityInfo.internalBinaryWrite(message.entityInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppFlag flag = 12; */
        if (message.flag)
            AppFlag.internalBinaryWrite(message.flag, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppMapMarkers mapMarkers = 13; */
        if (message.mapMarkers)
            AppMapMarkers.internalBinaryWrite(message.mapMarkers, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppCameraFrame cameraFrame = 14; */
        if (message.cameraFrame)
            AppCameraFrame.internalBinaryWrite(message.cameraFrame, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppResponse
 */
export const AppResponse = new AppResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppBroadcast$Type extends MessageType<AppBroadcast> {
    constructor() {
        super("rustplus.AppBroadcast", [
            { no: 4, name: "teamChanged", kind: "message", T: () => AppTeamChanged },
            { no: 5, name: "teamMessage", kind: "message", T: () => AppTeamMessage },
            { no: 6, name: "entityChanged", kind: "message", T: () => AppEntityChanged }
        ]);
    }
    create(value?: PartialMessage<AppBroadcast>): AppBroadcast {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppBroadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppBroadcast): AppBroadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.AppTeamChanged teamChanged */ 4:
                    message.teamChanged = AppTeamChanged.internalBinaryRead(reader, reader.uint32(), options, message.teamChanged);
                    break;
                case /* optional rustplus.AppTeamMessage teamMessage */ 5:
                    message.teamMessage = AppTeamMessage.internalBinaryRead(reader, reader.uint32(), options, message.teamMessage);
                    break;
                case /* optional rustplus.AppEntityChanged entityChanged */ 6:
                    message.entityChanged = AppEntityChanged.internalBinaryRead(reader, reader.uint32(), options, message.entityChanged);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppBroadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.AppTeamChanged teamChanged = 4; */
        if (message.teamChanged)
            AppTeamChanged.internalBinaryWrite(message.teamChanged, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTeamMessage teamMessage = 5; */
        if (message.teamMessage)
            AppTeamMessage.internalBinaryWrite(message.teamMessage, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEntityChanged entityChanged = 6; */
        if (message.entityChanged)
            AppEntityChanged.internalBinaryWrite(message.entityChanged, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppBroadcast
 */
export const AppBroadcast = new AppBroadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEmpty$Type extends MessageType<AppEmpty> {
    constructor() {
        super("rustplus.AppEmpty", []);
    }
    create(value?: PartialMessage<AppEmpty>): AppEmpty {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEmpty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEmpty): AppEmpty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AppEmpty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEmpty
 */
export const AppEmpty = new AppEmpty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSuccess$Type extends MessageType<AppSuccess> {
    constructor() {
        super("rustplus.AppSuccess", []);
    }
    create(value?: PartialMessage<AppSuccess>): AppSuccess {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSuccess): AppSuccess {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AppSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppSuccess
 */
export const AppSuccess = new AppSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppError$Type extends MessageType<AppError> {
    constructor() {
        super("rustplus.AppError", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppError>): AppError {
        const message = { error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppError): AppError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppError
 */
export const AppError = new AppError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppInfo$Type extends MessageType<AppInfo> {
    constructor() {
        super("rustplus.AppInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "headerImage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "map", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "mapSize", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "wipeTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "players", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "maxPlayers", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "queuedPlayers", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "salt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppInfo>): AppInfo {
        const message = { name: "", headerImage: "", url: "", map: "", mapSize: 0, wipeTime: 0, players: 0, maxPlayers: 0, queuedPlayers: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppInfo): AppInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string headerImage */ 2:
                    message.headerImage = reader.string();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                case /* string map */ 4:
                    message.map = reader.string();
                    break;
                case /* uint32 mapSize */ 5:
                    message.mapSize = reader.uint32();
                    break;
                case /* uint32 wipeTime */ 6:
                    message.wipeTime = reader.uint32();
                    break;
                case /* uint32 players */ 7:
                    message.players = reader.uint32();
                    break;
                case /* uint32 maxPlayers */ 8:
                    message.maxPlayers = reader.uint32();
                    break;
                case /* uint32 queuedPlayers */ 9:
                    message.queuedPlayers = reader.uint32();
                    break;
                case /* optional uint32 seed */ 10:
                    message.seed = reader.uint32();
                    break;
                case /* optional uint32 salt */ 11:
                    message.salt = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string headerImage = 2; */
        if (message.headerImage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.headerImage);
        /* string url = 3; */
        if (message.url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* string map = 4; */
        if (message.map !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.map);
        /* uint32 mapSize = 5; */
        if (message.mapSize !== 0)
            writer.tag(5, WireType.Varint).uint32(message.mapSize);
        /* uint32 wipeTime = 6; */
        if (message.wipeTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.wipeTime);
        /* uint32 players = 7; */
        if (message.players !== 0)
            writer.tag(7, WireType.Varint).uint32(message.players);
        /* uint32 maxPlayers = 8; */
        if (message.maxPlayers !== 0)
            writer.tag(8, WireType.Varint).uint32(message.maxPlayers);
        /* uint32 queuedPlayers = 9; */
        if (message.queuedPlayers !== 0)
            writer.tag(9, WireType.Varint).uint32(message.queuedPlayers);
        /* optional uint32 seed = 10; */
        if (message.seed !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.seed);
        /* optional uint32 salt = 11; */
        if (message.salt !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.salt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppInfo
 */
export const AppInfo = new AppInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTime$Type extends MessageType<AppTime> {
    constructor() {
        super("rustplus.AppTime", [
            { no: 1, name: "dayLengthMinutes", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "timeScale", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "sunrise", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "sunset", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "time", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppTime>): AppTime {
        const message = { dayLengthMinutes: 0, timeScale: 0, sunrise: 0, sunset: 0, time: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTime): AppTime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float dayLengthMinutes */ 1:
                    message.dayLengthMinutes = reader.float();
                    break;
                case /* float timeScale */ 2:
                    message.timeScale = reader.float();
                    break;
                case /* float sunrise */ 3:
                    message.sunrise = reader.float();
                    break;
                case /* float sunset */ 4:
                    message.sunset = reader.float();
                    break;
                case /* float time */ 5:
                    message.time = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float dayLengthMinutes = 1; */
        if (message.dayLengthMinutes !== 0)
            writer.tag(1, WireType.Bit32).float(message.dayLengthMinutes);
        /* float timeScale = 2; */
        if (message.timeScale !== 0)
            writer.tag(2, WireType.Bit32).float(message.timeScale);
        /* float sunrise = 3; */
        if (message.sunrise !== 0)
            writer.tag(3, WireType.Bit32).float(message.sunrise);
        /* float sunset = 4; */
        if (message.sunset !== 0)
            writer.tag(4, WireType.Bit32).float(message.sunset);
        /* float time = 5; */
        if (message.time !== 0)
            writer.tag(5, WireType.Bit32).float(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTime
 */
export const AppTime = new AppTime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMap$Type extends MessageType<AppMap> {
    constructor() {
        super("rustplus.AppMap", [
            { no: 1, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "jpgImage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "oceanMargin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "monuments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppMap_Monument },
            { no: 6, name: "background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppMap>): AppMap {
        const message = { width: 0, height: 0, jpgImage: new Uint8Array(0), oceanMargin: 0, monuments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMap): AppMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                case /* bytes jpgImage */ 3:
                    message.jpgImage = reader.bytes();
                    break;
                case /* int32 oceanMargin */ 4:
                    message.oceanMargin = reader.int32();
                    break;
                case /* repeated rustplus.AppMap.Monument monuments */ 5:
                    message.monuments.push(AppMap_Monument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string background */ 6:
                    message.background = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        /* bytes jpgImage = 3; */
        if (message.jpgImage.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.jpgImage);
        /* int32 oceanMargin = 4; */
        if (message.oceanMargin !== 0)
            writer.tag(4, WireType.Varint).int32(message.oceanMargin);
        /* repeated rustplus.AppMap.Monument monuments = 5; */
        for (let i = 0; i < message.monuments.length; i++)
            AppMap_Monument.internalBinaryWrite(message.monuments[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string background = 6; */
        if (message.background !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.background);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMap
 */
export const AppMap = new AppMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMap_Monument$Type extends MessageType<AppMap_Monument> {
    constructor() {
        super("rustplus.AppMap.Monument", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppMap_Monument>): AppMap_Monument {
        const message = { token: "", x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppMap_Monument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMap_Monument): AppMap_Monument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMap_Monument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMap.Monument
 */
export const AppMap_Monument = new AppMap_Monument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamInfo$Type extends MessageType<AppTeamInfo> {
    constructor() {
        super("rustplus.AppTeamInfo", [
            { no: 1, name: "leaderSteamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamInfo_Member },
            { no: 3, name: "mapNotes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamInfo_Note },
            { no: 4, name: "leaderMapNotes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamInfo_Note }
        ]);
    }
    create(value?: PartialMessage<AppTeamInfo>): AppTeamInfo {
        const message = { leaderSteamId: "0", members: [], mapNotes: [], leaderMapNotes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTeamInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamInfo): AppTeamInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 leaderSteamId = 1 [jstype = JS_STRING];*/ 1:
                    message.leaderSteamId = reader.uint64().toString();
                    break;
                case /* repeated rustplus.AppTeamInfo.Member members */ 2:
                    message.members.push(AppTeamInfo_Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated rustplus.AppTeamInfo.Note mapNotes */ 3:
                    message.mapNotes.push(AppTeamInfo_Note.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated rustplus.AppTeamInfo.Note leaderMapNotes */ 4:
                    message.leaderMapNotes.push(AppTeamInfo_Note.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 leaderSteamId = 1 [jstype = JS_STRING]; */
        if (message.leaderSteamId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.leaderSteamId);
        /* repeated rustplus.AppTeamInfo.Member members = 2; */
        for (let i = 0; i < message.members.length; i++)
            AppTeamInfo_Member.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated rustplus.AppTeamInfo.Note mapNotes = 3; */
        for (let i = 0; i < message.mapNotes.length; i++)
            AppTeamInfo_Note.internalBinaryWrite(message.mapNotes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated rustplus.AppTeamInfo.Note leaderMapNotes = 4; */
        for (let i = 0; i < message.leaderMapNotes.length; i++)
            AppTeamInfo_Note.internalBinaryWrite(message.leaderMapNotes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamInfo
 */
export const AppTeamInfo = new AppTeamInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamInfo_Member$Type extends MessageType<AppTeamInfo_Member> {
    constructor() {
        super("rustplus.AppTeamInfo.Member", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "isOnline", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "spawnTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "isAlive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "deathTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppTeamInfo_Member>): AppTeamInfo_Member {
        const message = { steamId: "0", name: "", x: 0, y: 0, isOnline: false, spawnTime: 0, isAlive: false, deathTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTeamInfo_Member>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamInfo_Member): AppTeamInfo_Member {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId = 1 [jstype = JS_STRING];*/ 1:
                    message.steamId = reader.uint64().toString();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                case /* bool isOnline */ 5:
                    message.isOnline = reader.bool();
                    break;
                case /* uint32 spawnTime */ 6:
                    message.spawnTime = reader.uint32();
                    break;
                case /* bool isAlive */ 7:
                    message.isAlive = reader.bool();
                    break;
                case /* uint32 deathTime */ 8:
                    message.deathTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamInfo_Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1 [jstype = JS_STRING]; */
        if (message.steamId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* bool isOnline = 5; */
        if (message.isOnline !== false)
            writer.tag(5, WireType.Varint).bool(message.isOnline);
        /* uint32 spawnTime = 6; */
        if (message.spawnTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.spawnTime);
        /* bool isAlive = 7; */
        if (message.isAlive !== false)
            writer.tag(7, WireType.Varint).bool(message.isAlive);
        /* uint32 deathTime = 8; */
        if (message.deathTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.deathTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamInfo.Member
 */
export const AppTeamInfo_Member = new AppTeamInfo_Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamInfo_Note$Type extends MessageType<AppTeamInfo_Note> {
    constructor() {
        super("rustplus.AppTeamInfo.Note", [
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppTeamInfo_Note>): AppTeamInfo_Note {
        const message = { type: 0, x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTeamInfo_Note>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamInfo_Note): AppTeamInfo_Note {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamInfo_Note, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamInfo.Note
 */
export const AppTeamInfo_Note = new AppTeamInfo_Note$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamChat$Type extends MessageType<AppTeamChat> {
    constructor() {
        super("rustplus.AppTeamChat", [
            { no: 1, name: "messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppChatMessage }
        ]);
    }
    create(value?: PartialMessage<AppTeamChat>): AppTeamChat {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTeamChat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamChat): AppTeamChat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rustplus.AppChatMessage messages */ 1:
                    message.messages.push(AppChatMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamChat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rustplus.AppChatMessage messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            AppChatMessage.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamChat
 */
export const AppTeamChat = new AppTeamChat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppChatMessage$Type extends MessageType<AppChatMessage> {
    constructor() {
        super("rustplus.AppChatMessage", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppChatMessage>): AppChatMessage {
        const message = { steamId: "0", name: "", message: "", color: "", time: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppChatMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppChatMessage): AppChatMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId = 1 [jstype = JS_STRING];*/ 1:
                    message.steamId = reader.uint64().toString();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* string color */ 4:
                    message.color = reader.string();
                    break;
                case /* uint32 time */ 5:
                    message.time = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppChatMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1 [jstype = JS_STRING]; */
        if (message.steamId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* string color = 4; */
        if (message.color !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.color);
        /* uint32 time = 5; */
        if (message.time !== 0)
            writer.tag(5, WireType.Varint).uint32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppChatMessage
 */
export const AppChatMessage = new AppChatMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityInfo$Type extends MessageType<AppEntityInfo> {
    constructor() {
        super("rustplus.AppEntityInfo", [
            { no: 1, name: "type", kind: "enum", T: () => ["rustplus.AppEntityType", AppEntityType] },
            { no: 3, name: "payload", kind: "message", T: () => AppEntityPayload }
        ]);
    }
    create(value?: PartialMessage<AppEntityInfo>): AppEntityInfo {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityInfo): AppEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* rustplus.AppEntityType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* rustplus.AppEntityPayload payload */ 3:
                    message.payload = AppEntityPayload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* rustplus.AppEntityType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* rustplus.AppEntityPayload payload = 3; */
        if (message.payload)
            AppEntityPayload.internalBinaryWrite(message.payload, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityInfo
 */
export const AppEntityInfo = new AppEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityPayload$Type extends MessageType<AppEntityPayload> {
    constructor() {
        super("rustplus.AppEntityPayload", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppEntityPayload_Item },
            { no: 3, name: "capacity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "hasProtection", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "protectionExpiry", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppEntityPayload>): AppEntityPayload {
        const message = { items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEntityPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityPayload): AppEntityPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool value */ 1:
                    message.value = reader.bool();
                    break;
                case /* repeated rustplus.AppEntityPayload.Item items */ 2:
                    message.items.push(AppEntityPayload_Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 capacity */ 3:
                    message.capacity = reader.int32();
                    break;
                case /* optional bool hasProtection */ 4:
                    message.hasProtection = reader.bool();
                    break;
                case /* optional uint32 protectionExpiry */ 5:
                    message.protectionExpiry = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Varint).bool(message.value);
        /* repeated rustplus.AppEntityPayload.Item items = 2; */
        for (let i = 0; i < message.items.length; i++)
            AppEntityPayload_Item.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 capacity = 3; */
        if (message.capacity !== undefined)
            writer.tag(3, WireType.Varint).int32(message.capacity);
        /* optional bool hasProtection = 4; */
        if (message.hasProtection !== undefined)
            writer.tag(4, WireType.Varint).bool(message.hasProtection);
        /* optional uint32 protectionExpiry = 5; */
        if (message.protectionExpiry !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.protectionExpiry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityPayload
 */
export const AppEntityPayload = new AppEntityPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityPayload_Item$Type extends MessageType<AppEntityPayload_Item> {
    constructor() {
        super("rustplus.AppEntityPayload.Item", [
            { no: 1, name: "itemId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemIsBlueprint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppEntityPayload_Item>): AppEntityPayload_Item {
        const message = { itemId: 0, quantity: 0, itemIsBlueprint: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEntityPayload_Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityPayload_Item): AppEntityPayload_Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 itemId */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                case /* bool itemIsBlueprint */ 3:
                    message.itemIsBlueprint = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityPayload_Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 itemId = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        /* bool itemIsBlueprint = 3; */
        if (message.itemIsBlueprint !== false)
            writer.tag(3, WireType.Varint).bool(message.itemIsBlueprint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityPayload.Item
 */
export const AppEntityPayload_Item = new AppEntityPayload_Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppFlag$Type extends MessageType<AppFlag> {
    constructor() {
        super("rustplus.AppFlag", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppFlag>): AppFlag {
        const message = { value: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppFlag): AppFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppFlag
 */
export const AppFlag = new AppFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMapMarkers$Type extends MessageType<AppMapMarkers> {
    constructor() {
        super("rustplus.AppMapMarkers", [
            { no: 1, name: "markers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppMarker }
        ]);
    }
    create(value?: PartialMessage<AppMapMarkers>): AppMapMarkers {
        const message = { markers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppMapMarkers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMapMarkers): AppMapMarkers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rustplus.AppMarker markers */ 1:
                    message.markers.push(AppMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMapMarkers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rustplus.AppMarker markers = 1; */
        for (let i = 0; i < message.markers.length; i++)
            AppMarker.internalBinaryWrite(message.markers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMapMarkers
 */
export const AppMapMarkers = new AppMapMarkers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector4$Type extends MessageType<Vector4> {
    constructor() {
        super("rustplus.Vector4", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Vector4>): Vector4 {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Vector4>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector4): Vector4 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                case /* optional float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector4, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* optional float w = 4; */
        if (message.w !== undefined)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Vector4
 */
export const Vector4 = new Vector4$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMarker$Type extends MessageType<AppMarker> {
    constructor() {
        super("rustplus.AppMarker", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["rustplus.AppMarkerType", AppMarkerType] },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "steamId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/ },
            { no: 6, name: "rotation", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "radius", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "color1", kind: "message", T: () => Vector4 },
            { no: 9, name: "color2", kind: "message", T: () => Vector4 },
            { no: 10, name: "alpha", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "sellOrders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppMarker_SellOrder }
        ]);
    }
    create(value?: PartialMessage<AppMarker>): AppMarker {
        const message = { id: 0, type: 0, x: 0, y: 0, sellOrders: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppMarker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMarker): AppMarker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* rustplus.AppMarkerType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                case /* optional uint64 steamId = 5 [jstype = JS_STRING];*/ 5:
                    message.steamId = reader.uint64().toString();
                    break;
                case /* optional float rotation */ 6:
                    message.rotation = reader.float();
                    break;
                case /* optional float radius */ 7:
                    message.radius = reader.float();
                    break;
                case /* optional rustplus.Vector4 color1 */ 8:
                    message.color1 = Vector4.internalBinaryRead(reader, reader.uint32(), options, message.color1);
                    break;
                case /* optional rustplus.Vector4 color2 */ 9:
                    message.color2 = Vector4.internalBinaryRead(reader, reader.uint32(), options, message.color2);
                    break;
                case /* optional float alpha */ 10:
                    message.alpha = reader.float();
                    break;
                case /* optional string name */ 11:
                    message.name = reader.string();
                    break;
                case /* repeated rustplus.AppMarker.SellOrder sellOrders */ 13:
                    message.sellOrders.push(AppMarker_SellOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMarker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* rustplus.AppMarkerType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* optional uint64 steamId = 5 [jstype = JS_STRING]; */
        if (message.steamId !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.steamId);
        /* optional float rotation = 6; */
        if (message.rotation !== undefined)
            writer.tag(6, WireType.Bit32).float(message.rotation);
        /* optional float radius = 7; */
        if (message.radius !== undefined)
            writer.tag(7, WireType.Bit32).float(message.radius);
        /* optional rustplus.Vector4 color1 = 8; */
        if (message.color1)
            Vector4.internalBinaryWrite(message.color1, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.Vector4 color2 = 9; */
        if (message.color2)
            Vector4.internalBinaryWrite(message.color2, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional float alpha = 10; */
        if (message.alpha !== undefined)
            writer.tag(10, WireType.Bit32).float(message.alpha);
        /* optional string name = 11; */
        if (message.name !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.name);
        /* repeated rustplus.AppMarker.SellOrder sellOrders = 13; */
        for (let i = 0; i < message.sellOrders.length; i++)
            AppMarker_SellOrder.internalBinaryWrite(message.sellOrders[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMarker
 */
export const AppMarker = new AppMarker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMarker_SellOrder$Type extends MessageType<AppMarker_SellOrder> {
    constructor() {
        super("rustplus.AppMarker.SellOrder", [
            { no: 1, name: "itemId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "currencyId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "costPerItem", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "amountInStock", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "itemIsBlueprint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "currencyIsBlueprint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppMarker_SellOrder>): AppMarker_SellOrder {
        const message = { itemId: 0, quantity: 0, currencyId: 0, costPerItem: 0, amountInStock: 0, itemIsBlueprint: false, currencyIsBlueprint: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppMarker_SellOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMarker_SellOrder): AppMarker_SellOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 itemId */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                case /* int32 currencyId */ 3:
                    message.currencyId = reader.int32();
                    break;
                case /* int32 costPerItem */ 4:
                    message.costPerItem = reader.int32();
                    break;
                case /* int32 amountInStock */ 5:
                    message.amountInStock = reader.int32();
                    break;
                case /* bool itemIsBlueprint */ 6:
                    message.itemIsBlueprint = reader.bool();
                    break;
                case /* bool currencyIsBlueprint */ 7:
                    message.currencyIsBlueprint = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMarker_SellOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 itemId = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        /* int32 currencyId = 3; */
        if (message.currencyId !== 0)
            writer.tag(3, WireType.Varint).int32(message.currencyId);
        /* int32 costPerItem = 4; */
        if (message.costPerItem !== 0)
            writer.tag(4, WireType.Varint).int32(message.costPerItem);
        /* int32 amountInStock = 5; */
        if (message.amountInStock !== 0)
            writer.tag(5, WireType.Varint).int32(message.amountInStock);
        /* bool itemIsBlueprint = 6; */
        if (message.itemIsBlueprint !== false)
            writer.tag(6, WireType.Varint).bool(message.itemIsBlueprint);
        /* bool currencyIsBlueprint = 7; */
        if (message.currencyIsBlueprint !== false)
            writer.tag(7, WireType.Varint).bool(message.currencyIsBlueprint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMarker.SellOrder
 */
export const AppMarker_SellOrder = new AppMarker_SellOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraFrame$Type extends MessageType<AppCameraFrame> {
    constructor() {
        super("rustplus.AppCameraFrame", [
            { no: 1, name: "frame", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "jpgImage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AppCameraFrame>): AppCameraFrame {
        const message = { frame: 0, jpgImage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppCameraFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraFrame): AppCameraFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 frame */ 1:
                    message.frame = reader.uint32();
                    break;
                case /* bytes jpgImage */ 2:
                    message.jpgImage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 frame = 1; */
        if (message.frame !== 0)
            writer.tag(1, WireType.Varint).uint32(message.frame);
        /* bytes jpgImage = 2; */
        if (message.jpgImage.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.jpgImage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraFrame
 */
export const AppCameraFrame = new AppCameraFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamChanged$Type extends MessageType<AppTeamChanged> {
    constructor() {
        super("rustplus.AppTeamChanged", [
            { no: 1, name: "playerId", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "teamInfo", kind: "message", T: () => AppTeamInfo }
        ]);
    }
    create(value?: PartialMessage<AppTeamChanged>): AppTeamChanged {
        const message = { playerId: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTeamChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamChanged): AppTeamChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 playerId = 1 [jstype = JS_STRING];*/ 1:
                    message.playerId = reader.uint64().toString();
                    break;
                case /* rustplus.AppTeamInfo teamInfo */ 2:
                    message.teamInfo = AppTeamInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 playerId = 1 [jstype = JS_STRING]; */
        if (message.playerId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.playerId);
        /* rustplus.AppTeamInfo teamInfo = 2; */
        if (message.teamInfo)
            AppTeamInfo.internalBinaryWrite(message.teamInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamChanged
 */
export const AppTeamChanged = new AppTeamChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamMessage$Type extends MessageType<AppTeamMessage> {
    constructor() {
        super("rustplus.AppTeamMessage", [
            { no: 1, name: "message", kind: "message", T: () => AppChatMessage }
        ]);
    }
    create(value?: PartialMessage<AppTeamMessage>): AppTeamMessage {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppTeamMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamMessage): AppTeamMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* rustplus.AppChatMessage message */ 1:
                    message.message = AppChatMessage.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* rustplus.AppChatMessage message = 1; */
        if (message.message)
            AppChatMessage.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamMessage
 */
export const AppTeamMessage = new AppTeamMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityChanged$Type extends MessageType<AppEntityChanged> {
    constructor() {
        super("rustplus.AppEntityChanged", [
            { no: 1, name: "entityId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "payload", kind: "message", T: () => AppEntityPayload }
        ]);
    }
    create(value?: PartialMessage<AppEntityChanged>): AppEntityChanged {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEntityChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityChanged): AppEntityChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entityId */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* rustplus.AppEntityPayload payload */ 2:
                    message.payload = AppEntityPayload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entityId = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* rustplus.AppEntityPayload payload = 2; */
        if (message.payload)
            AppEntityPayload.internalBinaryWrite(message.payload, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityChanged
 */
export const AppEntityChanged = new AppEntityChanged$Type();
